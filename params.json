{
  "name": "Node-patterns",
  "tagline": "Node Patterns: From Callbacks to Observer",
  "body": "footer: © NodeProgram.com, 2016\r\nslidenumbers: true\r\n\r\n# Node Patterns\r\n\r\n## From Callbacks to Observer\r\n\r\n---\r\n\r\n## The one true #JavaScript exception handler pattern\r\n\r\n![inline](images/full-stackoverflow.png)\r\n\r\n\r\n---\r\n\r\n\r\n## The one true Node exception handler pattern\r\n\r\n```js\r\nprocess.on('uncaughtException',\r\n  e => require('opn')(`http://stackoverflow.com/search?q=[node.js ]+${e.message}`)\r\n)\r\n```\r\n\r\n---\r\n\r\n# Why Turn off Your IM and Care?\r\n\r\n1. You want to write and organize code better\r\n1. You want to become a go-to Node person in your team\r\n1. You want to understand Node things a bit deeper\r\n\r\n---\r\n\r\n# Slides :page_facing_up:\r\n\r\n<https://github.com/azat-co/node-patterns>\r\n\r\n```\r\ngit clone https://github.com/azat-co/node-patterns\r\n```\r\n\r\n---\r\n\r\n# About Presenter\r\n\r\nAzat Mardan\r\n\r\n![inline](images/azat.jpeg)\r\n\r\nTwitter: @azat_co\r\nEmail: hi@azat.co\r\nBlog: webapplog.com\r\n\r\n---\r\n\r\n# About Presenter\r\n\r\n* Work: Technology Fellow at Capital One\r\n* Experience: FDIC, NIH, DocuSign, HackReactor and Storify\r\n* Books: Practical Node.js, Pro Express.js, Express.js API and 8 others\r\n* Teach: NodeProgram.com\r\n\r\n---\r\n\r\n![inline](images/azats-books-covers.png)\r\n\r\n---\r\n\r\n# Node Basics\r\n\r\n* JavaScript, but not \"===\"\r\n* Asynchronous + Event Driven\r\n* Non-Blocking I/O\r\n\r\n\r\n---\r\n\r\n# JavaScript? :unamused:\r\n\r\n* Async code is hard\r\n* Code complexity grows exponentially\r\n* Good code organization is important\r\n\r\n^So JavaScript can be tough\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to schedule something in the future?\r\n\r\n---\r\n\r\n# Callbacks All the Way!\r\n\r\nFunctions are First-Class Citizens\r\n\r\n---\r\n\r\n```js\r\nvar t = function(){...}\r\nsetTimeout(t, 1000)\r\n```\r\n\r\nt is a callback\r\n\r\n---\r\n\r\n# Callback Convention\r\n\r\n```js\r\nvar fs = require('fs')\r\nvar callback = function(error, data){...}\r\nfs.readFile('data.csv', 'utf-8', callback)\r\n```\r\n\r\n---\r\n\r\n# Conventions\r\n\r\n* `error` 1st argument, null if everything is okay\r\n* `data` is the second argument\r\n* `callback` is the last argument\r\n\r\n\r\n---\r\n\r\n# Note\r\n\r\nNaming doesn't matter but order matters.\r\n\r\nNode.js won't enforce the arguments.\r\n\r\nConvention is not a guarantee. It's just a style. — Read documentation or source code.\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to ensure the right sequence? Control flow 😕\r\n\r\n---\r\n\r\n# Example\r\n\r\nHTTP requests to:\r\n\r\n1. Get an auth token\r\n1. Fetch data\r\n1. PUT an update\r\n\r\nThey must be executed in a certain order.\r\n\r\n---\r\n\r\n```js\r\n... // callback is defined, callOne, callTwo, and callThree are defined\r\ncallOne({...}, function(error, data1) {\r\n    if (error) return callback(error, null)\r\n    // work to parse data1 to get auth token\r\n    // fetch the data from the API\r\n    callTwo(data1, function(error, data2) {\r\n        if (error) return callback(error, null)\r\n        // data2 is the response, transform it and make PUT call\r\n        callThree(data2, function(error, data3) {\r\n            //\r\n            if (error) return callback(error, null)\r\n            // parse the response\r\n            callback(null, data3)\r\n        })\r\n    })\r\n})\r\n```\r\n\r\n---\r\n\r\n# Welcome to callback hell\r\n\r\n---\r\n\r\n```js\r\nfs.readdir(source, function (err, files) {\r\n  if (err) {\r\n    console.log('Error finding files: ' + err)\r\n  } else {\r\n    files.forEach(function (filename, fileIndex) {\r\n      console.log(filename)\r\n      gm(source + filename).size(function (err, values) {\r\n        if (err) {\r\n          console.log('Error identifying file size: ' + err)\r\n        } else {\r\n          console.log(filename + ' : ' + values)\r\n          aspect = (values.width / values.height)\r\n          widths.forEach(function (width, widthIndex) {\r\n            height = Math.round(width / aspect)\r\n            console.log('resizing ' + filename + 'to ' + height + 'x' + height)\r\n            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {\r\n              if (err) console.log('Error writing file: ' + err)\r\n            })\r\n          }.bind(this))\r\n        }\r\n      })\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n# Callback Hell\r\n\r\n* Hard to read\r\n* Hard to modify/maintain/enhance\r\n* Easy for devs to make bugs\r\n* Closing parens - 👿\r\n\r\n### callbackhell.com\r\n\r\n---\r\n\r\n# Solutions\r\n\r\n* Abstract into named functions (hoisted or variables)\r\n* Use obververs\r\n* Use advanced libraries and techniques\r\n\r\n---\r\n\r\n# Named Functions\r\n\r\n```js\r\ncallOne({...}, processResponse1)\r\n\r\nfunction processResponse1(error, data1) {\r\n  callTwo(data1, processResponse2)\r\n}\r\n\r\nfunction processResponse2(error, data2) {\r\n  callThere(data2, processResponse3)\r\n}\r\n\r\nfunction processResponse3(error, data1) {\r\n  ...\r\n}\r\n```\r\n\r\n---\r\n\r\n# Modular Functions\r\n\r\n```js\r\nvar processResponse1 = require('./response1.js')\r\ncallOne({...}, processResponse1)\r\n```\r\n\r\n\r\n\r\n```js\r\n// response1.js\r\nvar processResponse2 = require('./response2.js')\r\nmodule.exports = function processResponse1(error, data1) {\r\n  callTwo(data1, processResponse2)\r\n}\r\n```\r\n\r\n---\r\n\r\n```js\r\n// response2.js\r\nvar processResponse3 = require('./response3.js')\r\nmodule.exports = function processResponse2(error, data2) {\r\n  callThere(data2, processResponse3)\r\n}\r\n```\r\n\r\n```js\r\n// response3.js\r\nmodule.exports = function processResponse3(error, data3) {\r\n  ...\r\n}\r\n```\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to modularize code properly?\r\n\r\n---\r\n\r\n* `module.exports = {...}`\r\n* `module.exports.obj = {...}`\r\n* `exports.obj = {...}`\r\n\r\nNote: `exports = {...}` is anti-pattern.\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to modularize dynamic code or where to initialize?\r\n\r\n---\r\n\r\n# Solution\r\n\r\n* `module.exports = function(options) {...}`\r\n* `module.exports.func = function(options) {...}`\r\n* `exports.func = function(options) {...}`\r\n\r\n\r\n---\r\n\r\n# Import\r\n\r\n```js\r\n// code A\r\nmodule.exports = function(options){\r\n  // code B\r\n}\r\n```\r\n\r\nWhen you `require`, code A is run and code B is not.\r\nCode A is run only once, no matter how many times you `require`.\r\nYou need to invoke the object to run code B.\r\n\r\n---\r\n\r\n# Demo\r\n\r\n```\r\nnode import-main\r\n```\r\n\r\n---\r\n\r\n# Importing Folders / Plugin Pattern\r\n\r\n```js\r\n// main.js\r\nvar routes = require('./routes')\r\n```\r\n\r\n```js\r\n// routes/index.js\r\nmodule.exports = {\r\n  users: require('./users.js'),\r\n  accounts: require('./accounts.js')\r\n  ...\r\n}\r\n```\r\n\r\n---\r\n\r\n# Singletons\r\n\r\n* `require`: modules are cached\r\n\r\n---\r\n\r\n```js\r\n// module.js\r\nvar a = 1 // Private\r\nmodule.exports = {\r\n  b: 2 // Public\r\n}\r\n```\r\n\r\n\r\n---\r\n\r\n```js\r\n// program.js\r\nvar m = require('./module')\r\nconsole.log(m.a) // undefined\r\nconsole.log(m.b) // 2\r\nm.b ++\r\nrequire('./main')\r\n```\r\n\r\n---\r\n\r\n\r\n```js\r\n// main.js\r\nvar m = require('./module')\r\nconsole.log(m.b) // 3\r\n```\r\n\r\n---\r\n\r\n# Demo\r\n\r\n```\r\nnode main.js\r\nnode program.js\r\n```\r\n\r\n---\r\n\r\n\r\n# Problem\r\n\r\nModules are cached on based on their resolved filename.\r\n\r\nFilename will break the caching\r\n\r\n```js\r\nvar m = require('./MODULE')\r\nvar m = require('./module')\r\n```\r\n\r\nOr different paths\r\n\r\n\r\n---\r\n\r\n# Solution\r\n\r\n`global`\r\n\r\n---\r\n\r\n\r\n`global.name`\r\n\r\nor\r\n\r\n`GLOBAL.name`\r\n\r\n\r\n\r\n---\r\n\r\n```js\r\n_log = global.console.log\r\nglobal.console.log = function(){\r\n  var args = arguments\r\n  args[0] = '\\033[31m' +args[0] + '\\x1b[0m'\r\n  return _log.apply(null, args)\r\n}\r\n```\r\n\r\n```\r\nrequire('./logs.js')\r\n```\r\n\r\n---\r\n\r\n# Color Logs\r\n\r\n```js\r\nglobal.error = global.console.error = msg =>\r\n  console.log( '\\x1b[31m\\x1b[1mError:\\x1b[22m \\x1b[93m' + msg + '\\x1b[0m' )\r\nglobal.info = global.console.info = msg =>\r\n  console.log( '\\x1b[31m\\x1b[36mInfo:\\x1b[22m \\x1b[93m\\x1b[0m' + msg )\r\nglobal.log = console.log\r\n```\r\n\r\n![200% inline](images/color-logs.png)\r\n\r\n---\r\n\r\nglobal is powerful... anti-pattern\r\n\r\nsimilar `window.jQuery = jQuery`\r\n\r\nuse it sparringly\r\n\r\n\r\n^with a lot of power comes a lot of responsibility\r\n\r\n---\r\n\r\n# Problem: How to organize your modular code into classes?\r\n\r\n* ES5 Classes are too complex (new, prototype, this)\r\n* ES6 Classes don't allow define property and other [issues](https://www.dropbox.com/s/9liftwj2g8jikjk/Screenshot%202016-06-20%2011.48.12.png?dl=0)\r\n\r\n---\r\n\r\n![inline](images/es6.png)\r\n\r\n---\r\n\r\n# Sidenote: Prototypes\r\n\r\nObjects inherit from other objects\r\n\r\nFunctions are objects too.\r\n\r\n---\r\n\r\n# Solution\r\n\r\nFunction factory for objects\r\n\r\n```js\r\nmodule.exports = function(options) {\r\n  // initialize\r\n  return {\r\n    getUsers: function() {...},\r\n    findUserById: function(){...},\r\n    limit: options.limit || 10,\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n# Solution 2\r\n\r\n`require('util').inherits(child, parent)`\r\n\r\n---\r\n\r\n# Problem\r\n\r\nEnhance functionality \"on the fly\"\r\n\r\n---\r\n\r\n# Decorator: Enhances an object\r\n\r\n```js\r\nlet userModel = function(options = {}) {\r\n return {\r\n   getUsers: function() {},\r\n   findUserById: function() {},\r\n   limit: options.limit || 10\r\n }\r\n}\r\nlet user = userModel()\r\nconsole.log(user.limit)\r\nlet adminModel = (userModel) => {\r\n  userModel.limit += 20\r\n  userModel.removeUser = () => {}\r\n  userModel.addUser = () => {}\r\n  return userModel\r\n}\r\nconsole.log(adminModel(user).limit)\r\n```\r\n// 10 30\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to enhance classes defined wit prototypal inheritance?\r\n\r\n---\r\n\r\nPrototype Decorator: Enhance global object\r\n\r\n```js\r\nObject.prototype.toPrettyJSON = function() {\r\n  console.log(this)\r\n  return JSON.stringify(this, null, 2)\r\n}\r\nlet obj = new Object({a: 1})\r\nconsole.log(obj.toPrettyJSON())\r\n```\r\n\r\nShould: https://github.com/shouldjs/should.js\r\n\r\n---\r\n\r\n# Problem\r\n\r\nNon-blocking I/O can be blocked 😢\r\n\r\n---\r\n\r\n## Have you ever seen this code?\r\n\r\n```js\r\nsetTimeout(function timeout() {\r\n  console.log('Hello Node')\r\n}, 0)\r\n```\r\n\r\n---\r\n\r\n```js\r\n// setimmediate.js\r\nsetImmediate(function A() {\r\n  setImmediate(function B() {\r\n    console.log('Step 1')\r\n  })\r\n  setImmediate(function C() {\r\n    console.log('Step 2')\r\n    setImmediate(function F() { console.log('Step 3') })\r\n    setImmediate(function G() { console.log('Step 4') })\r\n  })\r\n})\r\nconsole.log('Step 0')\r\nsetTimeout(function timeout() {\r\n  console.log('Timeout!')\r\n}, 0)\r\nconsole.log('Step 0.5')\r\n```\r\n\r\n// Step 0, Step 0.5, Timeout!, Step 1, Step 2, Step 3, Step 4\r\n\r\n^// Step 0, Step 0.5, Step 1, Step 2, Timeout!, Step 3, Step 4\r\n\r\n^setTimeout is on the next iteration of the event loop\r\n^setImmediate is also, after I/O and before timers (official docs). setImmediate allows you to distribute computation over many turns of the event loop while ensuring that I/O doesn't get starved\r\n^setTimeout is slower\r\n\r\n---\r\n\r\n```js\r\nprocess.nextTick(function A() {\r\n  process.nextTick(function B() {\r\n    console.log('Step 1')\r\n  })\r\n  process.nextTick(function C() {\r\n    console.log('Step 2')\r\n    process.nextTick(function F() { console.log('Step 3') })\r\n    process.nextTick(function G() { console.log('Step 4') })\r\n  })\r\n})\r\nconsole.log('Step 0')\r\nsetTimeout(function timeout() {\r\n  console.log('Timeout!')\r\n}, 0)\r\nconsole.log('Step 0.5')\r\n```\r\n\r\n// Step 0, Step 0.5, Step 1, Step 2, Step 3, Step 4, Timeout!\r\n\r\n^nextTick happens before I/O callbacks. So in a case where you're trying to break up a long running, CPU-bound job using recursion, you would now want to use setImmediate rather than process.nextTick to queue the next iteration as otherwise any I/O event callbacks wouldn't get the chance to run between iterations.\r\n\r\n---\r\n\r\n![inline](images/immediate-tick.png)\r\n\r\n---\r\n\r\n# Problem\r\n\r\nInsure continuity\r\n\r\n---\r\n\r\n## Node.js Middleware Pattern\r\n\r\nMiddleware pattern is a series of processing units connected together, where the output of one unit is the input for the next one. In Node.js, this often means a series of functions in the form:\r\n\r\n```js\r\nfunction(args, next) {\r\n  // ... Run some code\r\n  next(output) // Error or real output\r\n}\r\n```\r\n\r\n---\r\n\r\n## Express Example\r\n\r\nRequest is coming from a client and response is sent back to the client.\r\n\r\n```\r\nrequest->middleware1->middleware2->...middlewareN->route->response\r\n```\r\n\r\n\r\n---\r\n\r\n## Express.js Middleware\r\n\r\n```js\r\napp.use(function(request, response, next) {\r\n  // ...\r\n  next()\r\n}, function(request, response, next) {\r\n  next()\r\n}, function(request, response, next) {\r\n  next()\r\n})\r\n```\r\n\r\n---\r\n\r\n# Problems\r\n\r\n* Callbacks are still hard to manage even in modules!\r\n* Callbacks fire just once\r\n* Callbacks fire only at the end\r\n* No way to remove a callback or add a new one \"on the fly\"\r\n\r\n\r\n---\r\n\r\n## No it's not promises. 😉\r\n\r\n^Promises fire just once just as callbacks\r\n\r\n---\r\n\r\n# Example\r\n\r\n1. Module Job is performing a task.\r\n1. In the main file, we import Job.\r\n\r\nHow do we specify a callback (some future logic) on the Job's task completion?\r\n\r\n---\r\n\r\nMaybe:\r\n\r\n```js\r\nvar job = require('./job.js')(callback)\r\n```\r\n\r\n---\r\n\r\n\r\nWhat about multiple callbacks?\r\n\r\nNot very scalable 😢\r\n\r\n---\r\n\r\n# Solution\r\n\r\nObserver pattern with event emitters!\r\n\r\n---\r\n\r\n```js\r\n// module.js\r\nvar util = require('util')\r\nvar Job = function Job() {\r\n  // ...\r\n  this.process = function() {\r\n    // ...\r\n    this.emit('done', { completedOn: new Date() })\r\n  }\r\n}\r\n\r\nutil.inherits(Job, require('events').EventEmitter)\r\nmodule.exports = Job\r\n```\r\n\r\n^ module\r\n\r\n---\r\n\r\n```js\r\n// main.js\r\nvar Job = require('./module.js')\r\nvar job = new Job()\r\n\r\njob.on('done', function(details){\r\n  console.log('Job was completed at', details.completedOn)\r\n  job.removeAllListeners()\r\n})\r\n\r\njob.process()\r\n```\r\n\r\n^main\r\n\r\n---\r\n\r\n```js\r\nemitter.listeners(eventName)\r\nemitter.on(eventName, listener)\r\nemitter.once(eventName, listener)\r\nemitter.removeListener(eventName, listener)\r\n```\r\n\r\n\r\n---\r\n\r\n# More Async\r\n\r\n* `async` and `neo-async`\r\n* `co` and `bluebird`\r\n* Promises - not really helping much\r\n* Generators - promising\r\n* Async await - nice wrapper for promises\r\n\r\n\r\n---\r\n\r\n# Let's leave managing async for another talk.\r\n\r\n\r\n---\r\n\r\n## Dependency Injection\r\n\r\n## Express Middleware\r\n\r\n```js\r\nvar express = require('express')  \r\nvar app = express()  \r\nvar session = require('express-session')\r\n\r\napp.use(session({  \r\n  store: require('connect-session-knex')()\r\n}))\r\n```\r\n\r\n---\r\n\r\n# Hapi\r\n\r\n```js\r\nserver.views({  \r\n  engines: {\r\n    html: require('handlebars')\r\n  },\r\n  relativeTo: __dirname,\r\n  path: 'templates'\r\n})\r\n```\r\n\r\n---\r\n\r\n## Express Routes\r\n\r\n```js\r\n// server.js\r\nvar app = express()\r\n//...\r\napp.use(logger('dev'))\r\n//...\r\napp = require('./routes')(app)\r\napp.listen(3000)\r\n```\r\n\r\n---\r\n\r\n```js\r\n// routes/index.js\r\nmodule.exports = function(app) {\r\n  app.get('/users', require('./users.js').getUsers)\r\n  app.post('/order', require('./orders.js').addOrder)\r\n  //...\r\n  return app\r\n}\r\n```\r\n\r\n---\r\n\r\n# Problem\r\n\r\n```js\r\nlet f = ?\r\nlet a = f('Portland')\r\nlet b = f('Oakland')\r\nconsole.log(a('Hi')) // Hi Portland\r\nconsole.log(b('Hey')) // Hey Oakland\r\n```\r\n\r\n---\r\n\r\n# Function which returns a function (monad?)\r\n\r\n```js\r\n// routes/index.js\r\nmodule.exports = function(app){\r\n  return function(options, callback) {\r\n    app.listen(app.get('port'), options, callback)\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n# Useful modules\r\n\r\n* [`hooks`](https://github.com/bnoguchi/hooks-js)\r\n* [`require-dir`](https://www.npmjs.com/package/require-dir), [`require-directory`](https://www.npmjs.com/package/require-directory) and [`require-all`](https://www.npmjs.com/package/require-all)\r\n* [`opn`](https://github.com/sindresorhus/opn)\r\n\r\n^http://thenodeway.io and https://darrenderidder.github.io/talks/ModulePatterns/#/14\r\n\r\n---\r\n\r\n# There are more patterns!\r\n\r\n\r\n---\r\n\r\n# Node Patterns by Mario Casciaro\r\n\r\n![inline](images/nodedesignpatterns.jpg)\r\n\r\n<http://amzn.to/21hXxTy>\r\n\r\n---\r\n\r\n\r\n## 30-second Summary\r\n\r\n1. Callbacks\r\n1. Observer\r\n1. Singleton\r\n1. Plugins\r\n1. Middleware\r\n1. Bunch of other stuff 💥\r\n\r\n---\r\n\r\n## THE END\r\n\r\n1. Start with what you need\r\n1. Try and see what works for you (func vs. proto)\r\n1. Don't over engineers following the latest fad — stick to fundamentals!\r\n\r\nDon't fight with JavaScript/Node, use it!\r\n\r\n---\r\n\r\n# Rate This Talk 👍\r\n\r\nScale 1-10 (10 is highest)\r\n\r\nAnyone below 8?\r\n\r\nThis is your chance ask a question to make it 10!\r\n(If you don't ✋, then you rate 8+, right?)\r\n\r\n---\r\n\r\n# Code and Slides\r\n\r\n<https://github.com/azat-co/node-patterns/issues>\r\n\r\nTwitter: @azat_co\r\nEmail: hi@azat.co\r\n\r\nAlso, checkout NodeProgram.com",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}