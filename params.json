{
  "name": "Node-patterns",
  "tagline": "Node Patterns: From Callbacks to Observer",
  "body": "footer: ¬© NodeProgram.com, 2016\r\nslidenumbers: true\r\n\r\n# Node Patterns\r\n\r\n## From Callbacks to Observer\r\n\r\n---\r\n\r\n## The one true #JavaScript exception handler pattern\r\n\r\n![inline](images/full-stackoverflow.png)\r\n\r\n\r\n---\r\n\r\n\r\n## The one true Node exception handler pattern\r\n\r\n```js\r\nprocess.on('uncaughtException',\r\n  e => require('opn')(`http://stackoverflow.com/search?q=[node.js ]+${e.message}`)\r\n)\r\n```\r\n\r\n---\r\n\r\n# Why Turn off Your IM and Care?\r\n\r\n1. You want to write and organize code better\r\n1. You want to become a go-to Node person in your team\r\n1. You want to understand Node things a bit deeper\r\n\r\n---\r\n\r\n# Slides :page_facing_up:\r\n\r\n<https://github.com/azat-co/node-patterns>\r\n\r\n```\r\ngit clone https://github.com/azat-co/node-patterns\r\n```\r\n\r\n---\r\n\r\n# About Presenter\r\n\r\nAzat Mardan\r\n\r\n![inline](images/azat.jpeg)\r\n\r\nTwitter: @azat_co\r\nEmail: hi@azat.co\r\nBlog: webapplog.com\r\n\r\n---\r\n\r\n# About Presenter\r\n\r\n* Work: Technology Fellow at Capital One\r\n* Experience: FDIC, NIH, DocuSign, HackReactor and Storify\r\n* Books: Practical Node.js, Pro Express.js, Express.js API and 8 others\r\n* Teach: NodeProgram.com\r\n\r\n---\r\n\r\n![inline](images/azats-books-covers.png)\r\n\r\n---\r\n\r\n# Node Basics\r\n\r\n* JavaScript, but not \"===\"\r\n* Asynchronous + Event Driven\r\n* Non-Blocking I/O\r\n\r\n\r\n---\r\n\r\n# JavaScript? :unamused:\r\n\r\n* Async code is hard\r\n* Code complexity grows exponentially\r\n* Good code organization is important\r\n\r\n^So JavaScript can be tough\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to schedule something in the future?\r\n\r\n---\r\n\r\n# Callbacks All the Way!\r\n\r\nFunctions are First-Class Citizens\r\n\r\n---\r\n\r\n```js\r\nvar t = function(){...}\r\nsetTimeout(t, 1000)\r\n```\r\n\r\nt is a callback\r\n\r\n---\r\n\r\n# Callback Convention\r\n\r\n```js\r\nvar fs = require('fs')\r\nvar callback = function(error, data){...}\r\nfs.readFile('data.csv', 'utf-8', callback)\r\n```\r\n\r\n---\r\n\r\n# Conventions\r\n\r\n* `error` 1st argument, null if everything is okay\r\n* `data` is the second argument\r\n* `callback` is the last argument\r\n\r\n\r\n---\r\n\r\n# Note\r\n\r\nNaming doesn't matter but order matters.\r\n\r\nNode.js won't enforce the arguments.\r\n\r\nConvention is not a guarantee. It's just a style. ‚Äî Read documentation or source code.\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to ensure the right sequence? Control flow üòï\r\n\r\n---\r\n\r\n# Example\r\n\r\nHTTP requests to:\r\n\r\n1. Get an auth token\r\n1. Fetch data\r\n1. PUT an update\r\n\r\nThey must be executed in a certain order.\r\n\r\n---\r\n\r\n```js\r\n... // callback is defined, callOne, callTwo, and callThree are defined\r\ncallOne({...}, function(error, data1) {\r\n    if (error) return callback(error, null)\r\n    // work to parse data1 to get auth token\r\n    // fetch the data from the API\r\n    callTwo(data1, function(error, data2) {\r\n        if (error) return callback(error, null)\r\n        // data2 is the response, transform it and make PUT call\r\n        callThree(data2, function(error, data3) {\r\n            //\r\n            if (error) return callback(error, null)\r\n            // parse the response\r\n            callback(null, data3)\r\n        })\r\n    })\r\n})\r\n```\r\n\r\n---\r\n\r\n# Welcome to callback hell\r\n\r\n---\r\n\r\n```js\r\nfs.readdir(source, function (err, files) {\r\n  if (err) {\r\n    console.log('Error finding files: ' + err)\r\n  } else {\r\n    files.forEach(function (filename, fileIndex) {\r\n      console.log(filename)\r\n      gm(source + filename).size(function (err, values) {\r\n        if (err) {\r\n          console.log('Error identifying file size: ' + err)\r\n        } else {\r\n          console.log(filename + ' : ' + values)\r\n          aspect = (values.width / values.height)\r\n          widths.forEach(function (width, widthIndex) {\r\n            height = Math.round(width / aspect)\r\n            console.log('resizing ' + filename + 'to ' + height + 'x' + height)\r\n            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {\r\n              if (err) console.log('Error writing file: ' + err)\r\n            })\r\n          }.bind(this))\r\n        }\r\n      })\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n# Callback Hell\r\n\r\n* Hard to read\r\n* Hard to modify/maintain/enhance\r\n* Easy for devs to make bugs\r\n* Closing parens - üëø\r\n\r\n### callbackhell.com\r\n\r\n---\r\n\r\n# Solutions\r\n\r\n* Abstract into named functions (hoisted or variables)\r\n* Use obververs\r\n* Use advanced libraries and techniques\r\n\r\n---\r\n\r\n# Named Functions\r\n\r\n```js\r\ncallOne({...}, processResponse1)\r\n\r\nfunction processResponse1(error, data1) {\r\n  callTwo(data1, processResponse2)\r\n}\r\n\r\nfunction processResponse2(error, data2) {\r\n  callThere(data2, processResponse3)\r\n}\r\n\r\nfunction processResponse3(error, data1) {\r\n  ...\r\n}\r\n```\r\n\r\n---\r\n\r\n# Modular Functions\r\n\r\n```js\r\nvar processResponse1 = require('./response1.js')\r\ncallOne({...}, processResponse1)\r\n```\r\n\r\n\r\n\r\n```js\r\n// response1.js\r\nvar processResponse2 = require('./response2.js')\r\nmodule.exports = function processResponse1(error, data1) {\r\n  callTwo(data1, processResponse2)\r\n}\r\n```\r\n\r\n---\r\n\r\n```js\r\n// response2.js\r\nvar processResponse3 = require('./response3.js')\r\nmodule.exports = function processResponse2(error, data2) {\r\n  callThere(data2, processResponse3)\r\n}\r\n```\r\n\r\n```js\r\n// response3.js\r\nmodule.exports = function processResponse3(error, data3) {\r\n  ...\r\n}\r\n```\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to modularize code properly?\r\n\r\n---\r\n\r\n* `module.exports = {...}`\r\n* `module.exports.obj = {...}`\r\n* `exports.obj = {...}`\r\n\r\nNote: `exports = {...}` is anti-pattern.\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to modularize dynamic code or where to initialize?\r\n\r\n---\r\n\r\n# Solution\r\n\r\n* `module.exports = function(options) {...}`\r\n* `module.exports.func = function(options) {...}`\r\n* `exports.func = function(options) {...}`\r\n\r\n\r\n---\r\n\r\n# Import\r\n\r\n```js\r\n// code A\r\nmodule.exports = function(options){\r\n  // code B\r\n}\r\n```\r\n\r\nWhen you `require`, code A is run and code B is not.\r\nCode A is run only once, no matter how many times you `require`.\r\nYou need to invoke the object to run code B.\r\n\r\n---\r\n\r\n# Demo\r\n\r\n```\r\nnode import-main\r\n```\r\n\r\n---\r\n\r\n# Importing Folders / Plugin Pattern\r\n\r\n```js\r\n// main.js\r\nvar routes = require('./routes')\r\n```\r\n\r\n```js\r\n// routes/index.js\r\nmodule.exports = {\r\n  users: require('./users.js'),\r\n  accounts: require('./accounts.js')\r\n  ...\r\n}\r\n```\r\n\r\n---\r\n\r\n# Singletons\r\n\r\n* `require`: modules are cached\r\n\r\n---\r\n\r\n```js\r\n// module.js\r\nvar a = 1 // Private\r\nmodule.exports = {\r\n  b: 2 // Public\r\n}\r\n```\r\n\r\n\r\n---\r\n\r\n```js\r\n// program.js\r\nvar m = require('./module')\r\nconsole.log(m.a) // undefined\r\nconsole.log(m.b) // 2\r\nm.b ++\r\nrequire('./main')\r\n```\r\n\r\n---\r\n\r\n\r\n```js\r\n// main.js\r\nvar m = require('./module')\r\nconsole.log(m.b) // 3\r\n```\r\n\r\n---\r\n\r\n# Demo\r\n\r\n```\r\nnode main.js\r\nnode program.js\r\n```\r\n\r\n---\r\n\r\n\r\n# Problem\r\n\r\nModules are cached on based on their resolved filename.\r\n\r\nFilename will break the caching\r\n\r\n```js\r\nvar m = require('./MODULE')\r\nvar m = require('./module')\r\n```\r\n\r\nOr different paths\r\n\r\n\r\n---\r\n\r\n# Solution\r\n\r\n`global`\r\n\r\n---\r\n\r\n\r\n`global.name`\r\n\r\nor\r\n\r\n`GLOBAL.name`\r\n\r\n\r\n\r\n---\r\n\r\n```js\r\n_log = global.console.log\r\nglobal.console.log = function(){\r\n  var args = arguments\r\n  args[0] = '\\033[31m' +args[0] + '\\x1b[0m'\r\n  return _log.apply(null, args)\r\n}\r\n```\r\n\r\n```\r\nrequire('./logs.js')\r\n```\r\n\r\n---\r\n\r\n# Color Logs\r\n\r\n```js\r\nglobal.error = global.console.error = msg =>\r\n  console.log( '\\x1b[31m\\x1b[1mError:\\x1b[22m \\x1b[93m' + msg + '\\x1b[0m' )\r\nglobal.info = global.console.info = msg =>\r\n  console.log( '\\x1b[31m\\x1b[36mInfo:\\x1b[22m \\x1b[93m\\x1b[0m' + msg )\r\nglobal.log = console.log\r\n```\r\n\r\n![200% inline](images/color-logs.png)\r\n\r\n---\r\n\r\nglobal is powerful... anti-pattern\r\n\r\nsimilar `window.jQuery = jQuery`\r\n\r\nuse it sparringly\r\n\r\n\r\n^with a lot of power comes a lot of responsibility\r\n\r\n---\r\n\r\n# Problem: How to organize your modular code into classes?\r\n\r\n* ES5 Classes are too complex (new, prototype, this)\r\n* ES6 Classes don't allow define property and other [issues](https://www.dropbox.com/s/9liftwj2g8jikjk/Screenshot%202016-06-20%2011.48.12.png?dl=0)\r\n\r\n---\r\n\r\n![inline](images/es6.png)\r\n\r\n---\r\n\r\n# Sidenote: Prototypes\r\n\r\nObjects inherit from other objects\r\n\r\nFunctions are objects too.\r\n\r\n---\r\n\r\n# Solution\r\n\r\nFunction factory for objects\r\n\r\n```js\r\nmodule.exports = function(options) {\r\n  // initialize\r\n  return {\r\n    getUsers: function() {...},\r\n    findUserById: function(){...},\r\n    limit: options.limit || 10,\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n# Solution 2\r\n\r\n`require('util').inherits(child, parent)`\r\n\r\n---\r\n\r\n# Problem\r\n\r\nEnhance functionality \"on the fly\"\r\n\r\n---\r\n\r\n# Decorator: Enhances an object\r\n\r\n```js\r\nlet userModel = function(options = {}) {\r\n return {\r\n   getUsers: function() {},\r\n   findUserById: function() {},\r\n   limit: options.limit || 10\r\n }\r\n}\r\nlet user = userModel()\r\nconsole.log(user.limit)\r\nlet adminModel = (userModel) => {\r\n  userModel.limit += 20\r\n  userModel.removeUser = () => {}\r\n  userModel.addUser = () => {}\r\n  return userModel\r\n}\r\nconsole.log(adminModel(user).limit)\r\n```\r\n// 10 30\r\n\r\n---\r\n\r\n# Problem\r\n\r\nHow to enhance classes defined wit prototypal inheritance?\r\n\r\n---\r\n\r\nPrototype Decorator: Enhance global object\r\n\r\n```js\r\nObject.prototype.toPrettyJSON = function() {\r\n  console.log(this)\r\n  return JSON.stringify(this, null, 2)\r\n}\r\nlet obj = new Object({a: 1})\r\nconsole.log(obj.toPrettyJSON())\r\n```\r\n\r\nShould: https://github.com/shouldjs/should.js\r\n\r\n---\r\n\r\n# Problem\r\n\r\nNon-blocking I/O can be blocked üò¢\r\n\r\n---\r\n\r\n## Have you ever seen this code?\r\n\r\n```js\r\nsetTimeout(function timeout() {\r\n  console.log('Hello Node')\r\n}, 0)\r\n```\r\n\r\n---\r\n\r\n```js\r\n// setimmediate.js\r\nsetImmediate(function A() {\r\n  setImmediate(function B() {\r\n    console.log('Step 1')\r\n  })\r\n  setImmediate(function C() {\r\n    console.log('Step 2')\r\n    setImmediate(function F() { console.log('Step 3') })\r\n    setImmediate(function G() { console.log('Step 4') })\r\n  })\r\n})\r\nconsole.log('Step 0')\r\nsetTimeout(function timeout() {\r\n  console.log('Timeout!')\r\n}, 0)\r\nconsole.log('Step 0.5')\r\n```\r\n\r\n// Step 0, Step 0.5, Timeout!, Step 1, Step 2, Step 3, Step 4\r\n\r\n^// Step 0, Step 0.5, Step 1, Step 2, Timeout!, Step 3, Step 4\r\n\r\n^setTimeout is on the next iteration of the event loop\r\n^setImmediate is also, after I/O and before timers (official docs). setImmediate allows you to distribute computation over many turns of the event loop while ensuring that I/O doesn't get starved\r\n^setTimeout is slower\r\n\r\n---\r\n\r\n```js\r\nprocess.nextTick(function A() {\r\n  process.nextTick(function B() {\r\n    console.log('Step 1')\r\n  })\r\n  process.nextTick(function C() {\r\n    console.log('Step 2')\r\n    process.nextTick(function F() { console.log('Step 3') })\r\n    process.nextTick(function G() { console.log('Step 4') })\r\n  })\r\n})\r\nconsole.log('Step 0')\r\nsetTimeout(function timeout() {\r\n  console.log('Timeout!')\r\n}, 0)\r\nconsole.log('Step 0.5')\r\n```\r\n\r\n// Step 0, Step 0.5, Step 1, Step 2, Step 3, Step 4, Timeout!\r\n\r\n^nextTick happens before I/O callbacks. So in a case where you're trying to break up a long running, CPU-bound job using recursion, you would now want to use setImmediate rather than process.nextTick to queue the next iteration as otherwise any I/O event callbacks wouldn't get the chance to run between iterations.\r\n\r\n---\r\n\r\n![inline](images/immediate-tick.png)\r\n\r\n---\r\n\r\n# Problem\r\n\r\nInsure continuity\r\n\r\n---\r\n\r\n## Node.js Middleware Pattern\r\n\r\nMiddleware pattern is a series of processing units connected together, where the output of one unit is the input for the next one. In Node.js, this often means a series of functions in the form:\r\n\r\n```js\r\nfunction(args, next) {\r\n  // ... Run some code\r\n  next(output) // Error or real output\r\n}\r\n```\r\n\r\n---\r\n\r\n## Express Example\r\n\r\nRequest is coming from a client and response is sent back to the client.\r\n\r\n```\r\nrequest->middleware1->middleware2->...middlewareN->route->response\r\n```\r\n\r\n\r\n---\r\n\r\n## Express.js Middleware\r\n\r\n```js\r\napp.use(function(request, response, next) {\r\n  // ...\r\n  next()\r\n}, function(request, response, next) {\r\n  next()\r\n}, function(request, response, next) {\r\n  next()\r\n})\r\n```\r\n\r\n---\r\n\r\n# Problems\r\n\r\n* Callbacks are still hard to manage even in modules!\r\n* Callbacks fire just once\r\n* Callbacks fire only at the end\r\n* No way to remove a callback or add a new one \"on the fly\"\r\n\r\n\r\n---\r\n\r\n## No it's not promises. üòâ\r\n\r\n^Promises fire just once just as callbacks\r\n\r\n---\r\n\r\n# Example\r\n\r\n1. Module Job is performing a task.\r\n1. In the main file, we import Job.\r\n\r\nHow do we specify a callback (some future logic) on the Job's task completion?\r\n\r\n---\r\n\r\nMaybe:\r\n\r\n```js\r\nvar job = require('./job.js')(callback)\r\n```\r\n\r\n---\r\n\r\n\r\nWhat about multiple callbacks?\r\n\r\nNot very scalable üò¢\r\n\r\n---\r\n\r\n# Solution\r\n\r\nObserver pattern with event emitters!\r\n\r\n---\r\n\r\n```js\r\n// module.js\r\nvar util = require('util')\r\nvar Job = function Job() {\r\n  // ...\r\n  this.process = function() {\r\n    // ...\r\n    this.emit('done', { completedOn: new Date() })\r\n  }\r\n}\r\n\r\nutil.inherits(Job, require('events').EventEmitter)\r\nmodule.exports = Job\r\n```\r\n\r\n^ module\r\n\r\n---\r\n\r\n```js\r\n// main.js\r\nvar Job = require('./module.js')\r\nvar job = new Job()\r\n\r\njob.on('done', function(details){\r\n  console.log('Job was completed at', details.completedOn)\r\n  job.removeAllListeners()\r\n})\r\n\r\njob.process()\r\n```\r\n\r\n^main\r\n\r\n---\r\n\r\n```js\r\nemitter.listeners(eventName)\r\nemitter.on(eventName, listener)\r\nemitter.once(eventName, listener)\r\nemitter.removeListener(eventName, listener)\r\n```\r\n\r\n\r\n---\r\n\r\n# More Async\r\n\r\n* `async` and `neo-async`\r\n* `co` and `bluebird`\r\n* Promises - not really helping much\r\n* Generators - promising\r\n* Async await - nice wrapper for promises\r\n\r\n\r\n---\r\n\r\n# Let's leave managing async for another talk.\r\n\r\n\r\n---\r\n\r\n## Dependency Injection\r\n\r\n## Express Middleware\r\n\r\n```js\r\nvar express = require('express')  \r\nvar app = express()  \r\nvar session = require('express-session')\r\n\r\napp.use(session({  \r\n  store: require('connect-session-knex')()\r\n}))\r\n```\r\n\r\n---\r\n\r\n# Hapi\r\n\r\n```js\r\nserver.views({  \r\n  engines: {\r\n    html: require('handlebars')\r\n  },\r\n  relativeTo: __dirname,\r\n  path: 'templates'\r\n})\r\n```\r\n\r\n---\r\n\r\n## Express Routes\r\n\r\n```js\r\n// server.js\r\nvar app = express()\r\n//...\r\napp.use(logger('dev'))\r\n//...\r\napp = require('./routes')(app)\r\napp.listen(3000)\r\n```\r\n\r\n---\r\n\r\n```js\r\n// routes/index.js\r\nmodule.exports = function(app) {\r\n  app.get('/users', require('./users.js').getUsers)\r\n  app.post('/order', require('./orders.js').addOrder)\r\n  //...\r\n  return app\r\n}\r\n```\r\n\r\n---\r\n\r\n# Problem\r\n\r\n```js\r\nlet f = ?\r\nlet a = f('Portland')\r\nlet b = f('Oakland')\r\nconsole.log(a('Hi')) // Hi Portland\r\nconsole.log(b('Hey')) // Hey Oakland\r\n```\r\n\r\n---\r\n\r\n# Function which returns a function (monad?)\r\n\r\n```js\r\n// routes/index.js\r\nmodule.exports = function(app){\r\n  return function(options, callback) {\r\n    app.listen(app.get('port'), options, callback)\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n# Useful modules\r\n\r\n* [`hooks`](https://github.com/bnoguchi/hooks-js)\r\n* [`require-dir`](https://www.npmjs.com/package/require-dir), [`require-directory`](https://www.npmjs.com/package/require-directory) and [`require-all`](https://www.npmjs.com/package/require-all)\r\n* [`opn`](https://github.com/sindresorhus/opn)\r\n\r\n^http://thenodeway.io and https://darrenderidder.github.io/talks/ModulePatterns/#/14\r\n\r\n---\r\n\r\n# There are more patterns!\r\n\r\n\r\n---\r\n\r\n# Node Patterns by Mario Casciaro\r\n\r\n![inline](images/nodedesignpatterns.jpg)\r\n\r\n<http://amzn.to/21hXxTy>\r\n\r\n---\r\n\r\n\r\n## 30-second Summary\r\n\r\n1. Callbacks\r\n1. Observer\r\n1. Singleton\r\n1. Plugins\r\n1. Middleware\r\n1. Bunch of other stuff üí•\r\n\r\n---\r\n\r\n## THE END\r\n\r\n1. Start with what you need\r\n1. Try and see what works for you (func vs. proto)\r\n1. Don't over engineers following the latest fad ‚Äî stick to fundamentals!\r\n\r\nDon't fight with JavaScript/Node, use it!\r\n\r\n---\r\n\r\n# Rate This Talk üëç\r\n\r\nScale 1-10 (10 is highest)\r\n\r\nAnyone below 8?\r\n\r\nThis is your chance ask a question to make it 10!\r\n(If you don't ‚úã, then you rate 8+, right?)\r\n\r\n---\r\n\r\n# Code and Slides\r\n\r\n<https://github.com/azat-co/node-patterns/issues>\r\n\r\nTwitter: @azat_co\r\nEmail: hi@azat.co\r\n\r\nAlso, checkout NodeProgram.com",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}